---
title: "Lost_Wheel_Serial_Communication"
author: "JJ Bivona"
date: "9/6/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## call packages needed

```{r message=FALSE}

library(serial)
library(tidyverse)
library(ggplot2)
library(ggpubr)
library(dplyr)
library(data.table)
library(tibble)
library(stringr)
library(tidyr)
library(zoo)

```

# connect to wheel

### configure the COM port to the appropriate USB input.

### you can see what ports are active using listPorts()

### change name of wheel if multiple wheels running

```{r}
con<-serialConnection(name = "wheel", port = "com7", 
                      mode = "9600,n,8,1",
                      buffering = "full",
                      newline = "0",
                      eof = "",
                      translation = "auto",
                      handshake = "none",
                      buffersize = "100000000")
```

## determine how long you wish to collect data for. Enter time in hours

```{r}
timecollecth <- 0.01
```

## this code will run until the time interval is completed

```{r results=FALSE }


lengthofcollect <- timecollecth*60*60 #turning hours into seconds


wheelmatrix <- matrix(NA,lengthofcollect,2) #setting up matrix to collect data

close(con) #turn off wheel
Sys.sleep(0.5) #hold 
open(con) #turn on wheel
Sys.sleep(3.5) #startuptime is 3 seconds so hold some more


#loop to collect data

for (i in 1:lengthofcollect) { #keep collecting until lengthofcollect is reached
  
  
  lastread <- read.serialConnection(con) #read the serial output
  wheelmatrix[i,2]<-lastread #put the distance into the matrix
  Sys.sleep(1) #wait a second until the wheel sends next value 
  print(paste("wheel collection ongoing - min remaining:", round(((lengthofcollect-i)/60),1)))
}

close(con) #turn off wheel
```

## turn data into the correct format

```{r}
splitstringmatrix <- matrix(NA,lengthofcollect,3)
wheelmatrix[,2] -> splitstringmatrix[,1]
splitstringmatrix[,2:3]<-str_split_fixed(splitstringmatrix[,1], " , ", 2)


wheel_mat_numeric <- matrix(NA, lengthofcollect,4)

colnames(wheel_mat_numeric) <-c("time","distance","slope", "rolling velocity avg")
wheel_mat_numeric[,1] <- as.numeric(splitstringmatrix[,2]) #turn strings into numeric (factor)
wheel_mat_numeric[,2] <- as.numeric(splitstringmatrix[,3])
wheeltibble <- as_tibble(wheel_mat_numeric) #turn matrix into dataframe

```

## run all the calculations to make plots, velocity, time spent running

```{r}
dtplot <- wheeltibble %>% 
  rename(time_sec = time, distance_m = distance) %>% 
  ggplot(aes(time_sec, distance_m, group = 1)) +
  geom_point() +
  geom_line()



#calculate max speed by calculating slope
for (i in 1:lengthofcollect){
  wheeltibble[i:(lengthofcollect-1),3]<- ((wheeltibble[i+1,2]-wheeltibble[i,2])/(wheeltibble[i+1,1]-wheeltibble[i,1]))
  
}

vtplot <- wheeltibble %>% 
  rename(time_sec = time, velocity_m_per_s = slope) %>% 
  ggplot(aes(time_sec, velocity_m_per_s, group = 1)) +
  geom_point() +
    geom_line()+
 geom_line(aes(y=rollmean(wheeltibble[,3],5,na.pad=TRUE)), color = "orange",size = 3) 

maxspeed <- max(wheeltibble[,3],na.rm = TRUE)



#####calculate time spent running 


wheeltibble[,4]<-rollmean(wheeltibble[,3],4, na.pad=TRUE) #calculate a rolling mean to clean up any noise
cleanwheeltibble<-na.omit(wheeltibble) ##get rid of any NAs



for (i in 1:lengthofcollect){  #loop to set threshold that changes very slow turns into 0 b/c likely not running 
  
  ifelse(cleanwheeltibble[i,3]>0.2,cleanwheeltibble[i,5]<- cleanwheeltibble[i,3],cleanwheeltibble[i,5] <- 0) 
  
  }
names(cleanwheeltibble)[5]<-"clean_velocity"#rename new column


finaltibble <- cleanwheeltibble %>%
  mutate(t_lead = lead(time)-time) 

timestopped <- finaltibble %>%
  filter(clean_velocity == 0) %>%
  na.omit() %>%
  summarize(sum_time = sum(t_lead))


timeran <- (last(finaltibble[,1]) - timestopped)
finaldistance <- last(finaltibble[,2]-0)

```

## print final data report

```{r, warning=FALSE}

FinalReport<-tibble("maximum speed (m/s):" = round(maxspeed,2), 
       "time spent running (s):" = round(timeran[1,1],2),
       "final distance (m):"= finaldistance[1,1])
FinalReport 
dtplot
vtplot
     
```
